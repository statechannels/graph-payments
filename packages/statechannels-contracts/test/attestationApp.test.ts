import {Contract, constants, ethers} from 'ethers';
import {SigningKey, randomBytes, joinSignature} from 'ethers/lib/utils';

import {
  encodeOutcome,
  AssetOutcomeShortHand,
  replaceAddressesAndBigNumberify,
  randomExternalDestination,
  VariablePart,
  Outcome
} from '@statechannels/nitro-protocol';
import {expectRevert} from '@statechannels/devtools';
import Artifact from '../artifacts/contracts/AttestationApp.sol/AttestationApp.json';
import {AppData, fromJS, nullState, toJS} from '../src/utils/app-data';
import {BN, makeDestination} from '@statechannels/wallet-core';
import {fixture} from './fixture';
import {toAttestationProvided} from '../src';
import {Allocation, AllocationItem} from '@statechannels/client-api-schema';

const {AddressZero, HashZero} = constants;

// For some reason the JsonRPcProvider symbol is not the same as
// the ethers.providers.JsonRpcProvider. Need to resolve.
const testProvider = new ethers.providers.JsonRpcProvider(
  `http://localhost:${process.env.GANACHE_PORT}`
);

let AttestationApp: Contract;

const signer1 = new ethers.Wallet(
  '0x2143e68b42c8aefdf339ec3b59a576a3ccf42e47c7015a9e72b90de1a6cbeb1c'
); // 0xfbcc34578550891766161E88A089C884367760F5
const signer2 = new ethers.Wallet(
  '0xa69a8d9fde414bdf8b5d76bbff63bd78704fe3da1d938cd10126a9e2e3e0e11f'
);

const nPeers = 2;
const addresses = {
  A1: signer1.address,
  A2: signer2.address
};
const destinations = {
  G: randomExternalDestination(),
  A1: makeDestination(addresses.A1),
  A2: makeDestination(addresses.A2)
};

export async function setupContracts(
  provider: ethers.providers.JsonRpcProvider,
  {abi}: typeof import('../artifacts/contracts/AttestationApp.sol/AttestationApp.json'),
  address: string
): Promise<Contract> {
  return new Contract(address, abi, provider.getSigner(0));
}
const REQUEST_CID = '0xd902c18a1b3590a3d2a8ae4439db376764fda153ca077e339d0427bf776bd463';
const RESPONSE_CID = '0xd902c18a1b3590a3d2a8ae4439db376764fda153ca077e339d0427bf776bd463';
const CHAIN_ID = 4;
const SUBGRAPH_DEPLOYMENT_ID = HashZero;
const VERIFYING_CONTRACT = '0x1111111111111111111111111111111111122222';
const receipt = {
  requestCID: REQUEST_CID,
  responseCID: RESPONSE_CID,
  subgraphDeploymentID: SUBGRAPH_DEPLOYMENT_ID
};

// Generated by calling
// signAttestation(
//   signer2.privateKey,
//   REQUEST_CID,
//   RESPONSE_CID,
//   SUBGRAPH_DEPLOYMENT_ID,
//   CHAIN_ID,
//   VERIFYING_CONTRACT
// ).then(console.log);
const attestation = {
  A1:
    '0x3748764478fa9546b69f2547c1b9ee71ec2f3aad87b3aa9997f5fa4191b246ae05add0098735e97ecb2102d54670d66626dd2eba04b5571a787b29fe7b20d5671c',
  A2:
    '0xdc4b45154f7c680b855d9989009f4e02207f5087008da570c354d34914d982682b9f0a29e659a3a717b54daba26e39b9418b8776819d2ae0e244a74e44185c9b1b'
};

beforeAll(async () => {
  await testProvider.ready;
  AttestationApp = await setupContracts(
    testProvider,
    Artifact,
    process.env.ATTESTATION_APP as string
  );
});

describe('state transitions', () => {
  const INVALID_QUERY_REQUEST = /RequestCID must be non-zero/i;
  const INVALID_ATTESTATION_SIGNATURE = /must be signed with the allocationId/i;
  const INVALID_TRANSITION_TO_QueryRequest = /RequestCID must be zero/i;
  const INVALID_TRANSITION_TO_AttestationProvided = /ResponseCID must be zero/i;
  const INVALID_TRANSITION_TO_QueryDeclined = /RequestCID must be non-zero/i;

  const baseState: AppData = {
    constants: {
      verifyingContract: VERIFYING_CONTRACT,
      chainId: CHAIN_ID,
      maxAllocationItems: 20,
      subgraphDeploymentID: nullState.constants.subgraphDeploymentID
    },
    variable: {
      allocationId: nullState.variable.allocationId,
      paymentAmount: nullState.variable.paymentAmount,
      requestCID: nullState.variable.requestCID,
      responseCID: nullState.variable.responseCID,
      signature: nullState.variable.signature
    }
  };
  const {requestCID, responseCID} = receipt;
  const wrongSignature = joinSignature(new SigningKey(randomBytes(64)).signDigest('0xabcdef'));

  const appData = fixture<AppData>(baseState);

  const noRequestCID = appData({});
  const goodQuery = (key: 'A1' | 'A2') =>
    appData({
      variable: {requestCID, paymentAmount: BN.from(2), allocationId: addresses[key]}
    });
  const badSignature = appData({
    variable: {requestCID, responseCID, signature: wrongSignature, allocationId: addresses.A1}
  });
  const goodAttest = (key: 'A1' | 'A2') =>
    appData({
      variable: {responseCID, requestCID, signature: attestation[key], allocationId: addresses[key]}
    });
  // const badDecline = goodQuery;
  const goodDecline = (key: 'A1' | 'A2') =>
    appData({variable: {requestCID: HashZero, allocationId: addresses[key]}});

  const order = [destinations.G, destinations.A1, destinations.A2];
  const constructTestData = (
    bals: AssetOutcomeShortHand,
    appData: AppData
  ): {outcome: Outcome; appData: string} => {
    bals = replaceAddressesAndBigNumberify(bals, destinations) as AssetOutcomeShortHand;
    const items: AllocationItem[] = [];
    order.map((k) => bals[k] && items.push({destination: k, amount: BN.from(bals[k])}));
    const outcome = [{assetHolderAddress: AddressZero, allocationItems: items}];

    return {outcome, appData: fromJS(appData)};
  };

  const constructVariableParts = (
    bals: AssetOutcomeShortHand,
    richAppData: AppData
  ): VariablePart => {
    const {outcome, appData} = constructTestData(bals, richAppData);
    return {outcome: encodeOutcome(outcome), appData};
  };
  const throwHumanReadableError = (error) => {
    if ('body' in error) {
      const body = JSON.parse(error.body);
      throw new Error(body.error.message);
    } else {
      console.warn(Object.keys(error));
      throw error;
    }
  };

  type ValidTransitionCase = {
    fromAppData: AppData;
    toAppData: AppData;
    fromBalances: AssetOutcomeShortHand;
    toBalances: AssetOutcomeShortHand;
    turnNum: number;
    description: string;
  };
  it.each`
    fromAppData          | toAppData            | fromBalances            | toBalances              | turnNum | description
    ${goodQuery('A1')}   | ${goodAttest('A1')}  | ${{G: 6}}               | ${{G: 4, A1: 2}}        | ${3}    | ${'QueryRequest->GoodAttestation'}
    ${goodQuery('A1')}   | ${goodAttest('A1')}  | ${{G: 6, A1: 2}}        | ${{G: 4, A1: 4}}        | ${3}    | ${'QueryRequest->GoodAttestation'}
    ${goodQuery('A1')}   | ${goodAttest('A1')}  | ${{G: 6, A1: 2, A2: 2}} | ${{G: 4, A1: 4, A2: 2}} | ${3}    | ${'QueryRequest->GoodAttestation'}
    ${goodQuery('A2')}   | ${goodAttest('A2')}  | ${{G: 6, A1: 3}}        | ${{G: 4, A1: 3, A2: 2}} | ${3}    | ${'QueryRequest->GoodAttestation'}
    ${goodQuery('A2')}   | ${goodAttest('A2')}  | ${{G: 2, A1: 3}}        | ${{G: 0, A1: 3, A2: 2}} | ${3}    | ${'QueryRequest->GoodAttestation'}
    ${goodAttest('A1')}  | ${goodQuery('A1')}   | ${{G: 6}}               | ${{G: 6}}               | ${4}    | ${'GoodAttestation->QueryRequest'}
    ${goodQuery('A1')}   | ${goodDecline('A1')} | ${{G: 6}}               | ${{G: 6}}               | ${3}    | ${'QueryRequest->QueryDeclined'}
    ${goodDecline('A1')} | ${goodQuery('A1')}   | ${{G: 6}}               | ${{G: 6}}               | ${4}    | ${'QueryDeclined->QueryRequest'}
  `(
    `There is a valid transition for $description`,
    async ({fromAppData, toAppData, fromBalances, toBalances, turnNum}: ValidTransitionCase) => {
      const fromVars = constructVariableParts(fromBalances, fromAppData);
      const toVars = constructVariableParts(toBalances, toAppData);

      const {validTransition} = AttestationApp;
      const isValidFromCall = validTransition(fromVars, toVars, turnNum, nPeers).catch(
        throwHumanReadableError
      );
      await expect(isValidFromCall).resolves.toBe(true);
    }
  );

  type BadTestCase = {fromAppData: AppData; toAppData: AppData; turnNum: number; errorMsg: string};
  // TODO: These should be refactored around the new AttestationApp design
  it.each`
    fromAppData          | toAppData            | turnNum | errorMsg
    ${baseState}         | ${noRequestCID}      | ${2}    | ${INVALID_QUERY_REQUEST}
    ${goodQuery('A1')}   | ${badSignature}      | ${3}    | ${INVALID_ATTESTATION_SIGNATURE}
    ${goodQuery('A1')}   | ${goodQuery('A1')}   | ${3}    | ${INVALID_TRANSITION_TO_QueryRequest}
    ${goodAttest('A1')}  | ${goodAttest('A1')}  | ${4}    | ${INVALID_TRANSITION_TO_AttestationProvided}
    ${goodDecline('A1')} | ${goodAttest('A1')}  | ${4}    | ${INVALID_TRANSITION_TO_AttestationProvided}
    ${goodAttest('A1')}  | ${goodDecline('A1')} | ${4}    | ${INVALID_TRANSITION_TO_QueryDeclined}
    ${goodDecline('A1')} | ${goodDecline('A1')} | ${4}    | ${INVALID_TRANSITION_TO_QueryDeclined}
  `(
    `Handles error: $errorMsg`,
    async ({fromAppData, toAppData, turnNum, errorMsg}: BadTestCase) => {
      const balances = {G: 0, A1: 0};
      const fromVars = constructVariableParts(balances, fromAppData);
      const toVars = constructVariableParts(balances, toAppData);

      await expectRevert(
        () =>
          AttestationApp.validTransition(fromVars, toVars, turnNum, nPeers).catch(
            throwHumanReadableError
          ),
        errorMsg
      );
    }
  );

  type AttestationProvidedCase = {
    key: 'A1' | 'A2';
    fromBalances: AssetOutcomeShortHand;
    toBalances: AssetOutcomeShortHand;
  };
  it.each`
    key     | fromBalances            | toBalances
    ${'A1'} | ${{G: 6}}               | ${{G: 4, A1: 2}}
    ${'A1'} | ${{G: 6, A1: 2}}        | ${{G: 4, A1: 4}}
    ${'A1'} | ${{G: 6, A1: 2, A2: 2}} | ${{G: 4, A1: 4, A2: 2}}
    ${'A1'} | ${{G: 2, A1: 2, A2: 2}} | ${{G: 0, A1: 4, A2: 2}}
    ${'A2'} | ${{G: 6, A1: 2, A2: 2}} | ${{G: 4, A1: 2, A2: 4}}
    ${'A2'} | ${{G: 2, A1: 2, A2: 2}} | ${{G: 0, A1: 2, A2: 4}}
    ${'A2'} | ${{G: 6, A1: 3}}        | ${{G: 4, A1: 3, A2: 2}}
    ${'A2'} | ${{G: 2, A1: 3}}        | ${{G: 0, A1: 3, A2: 2}}
  `(`toAttestationProvided`, ({fromBalances, toBalances, key}: AttestationProvidedCase) => {
    const fromAppData = goodQuery(key);
    const toAppData = goodAttest(key);
    const fromVars = constructTestData(fromBalances, fromAppData);
    const toVars = constructTestData(toBalances, toAppData);
    const result = toAttestationProvided(
      fromVars.appData,
      fromVars.outcome[0] as Allocation,
      receipt.responseCID,
      attestation[key]
    );

    expect(toJS(toVars.appData)).toMatchObject(toJS(result.appData));
    expect(toVars.outcome[0]).toMatchObject(result.allocation);
    //
  });
});
